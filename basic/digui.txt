递归是一种强有力的技巧，但是和其他技巧一样，它也可能被误用。这里就有一个例子。阶乘的定义往往就是以递归的形式描述的。factorial(n)=1,n<=0; factorial(n)=n*factorial(n-1),n>0;

这个定义同时具备了递归所需要的两个特性：1、存在限制条件，当符合这个条件时递归便不再继续；2、每次递归调用之后越来越接近这个限制条件。用这种方式定义阶乘往往引导人们使用递归来实现阶乘函数。程序如下所示：
复制代码

 //用递归方法计算n的阶乘
 long factorial(int n)
     {
                if(n<=0)
             
                  return 1;
         
               else
             
                  return  n*factorial(n-1);
         
             }



               但它不是递归的良好用法。为什么呢？因为递归函数调用将涉及一些运行时开销——参数必须压到堆栈中，为局部变量分配内存空间（所有递归均如此，并非特指这个例子），寄存器的值必须保存等。当递归函数的每次调用返回时，上述这些操作必须还原，恢复成原来的样子。所以，基于这些开销，对于这个程序而言，它并没有简化问题的解决方案。下面这个函数是尾部递归的一个例子，由于函数在递归调用返回后不再执行任何任务，所以尾部递归可以很方便的转换成一个简单循环，完成相同的任务 ，程序效率更为有效。

                 //用迭代的方法计算n的阶乘
                  
                   long factorial(int n)
      
       {
            
                      int result=1;
             
                       while(n>1)
                  
                       {
                      
                               result*=n;
                      
                                n-=1;
                      
                                }
             
                       return result;
             
                 }



                许多问题是以递归的形式进行解释的，这只是因为它比非递归形式更为清晰。但是，这些问题的迭代往往比递归实现效率更高，代码的可读性可能稍差一些。当一个问题相当复杂，难以用迭代形式实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销。当你使用递归时候，一定要考虑它所带来的好处与它的代价之间的比较。
